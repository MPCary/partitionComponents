{
    "contents" : "#' Partition a component matrix\n#' \n#' Given a numeric matrix, returns a matrix with the same dimensions, row and \n#' column names but with only 1, 0, and -1 as values.  These values indicate the\n#' partitioning of each column of the matrix into positive, neither, and \n#' negative subsets.\n#' \n#' @usage\n#' partition(x, FUN, ...)\n#'   \n#' partition.functions\n#' # c(\"fixed\", \"ann\")\n#' @param x A numeric matrix\n#' @param FUN Function to use to determine threshold values for partitioning x\n#' @param ... Optional arguments to FUN\n#' @details Built-in partition functions are listed in the \n#'   \\code{partition.functions} vector.  The (\"\\code{fixed}\") function uses a\n#'   fixed value (specified by an additional parameter, \\code{t}) to create\n#'   partitions, while the (\"\\code{ann}\") function uses an artificial neural\n#'   network model to create custom partition thresholds for each component. \n#'   Additional user-defined functions are allowed.  These should return a\n#'   matrix with two rows and as many columns as in \\code{x}; the first row of\n#'   this matrix specifies the upper partition threshold for each column of\n#'   \\code{x}, while the second row specifies the lower partition threshold.\n#' @return A matrix comprising values of 1, 0, and -1 to indicate column-wise \n#'   partitioning of the input matrix into positive, neither, and negative sets,\n#'   respectively.\n#' @examples\n#' x = matrix(rnorm(9), 3, 3)\n#' partition(x, FUN = \".fixed\", t = 0.5)\npartition <- function(x, FUN, ...) {\n  x = .checkMatrix(x) # Check x for well-formedness\n\n  thresholds = get(FUN)(x, ...) # Run FUN to obtain thresholds for each column\n  d = dim(thresholds)\n  if((d[1] != 2) | (d[2] != ncol(x))) {\n    stop(\"Partition threshold function failed\")\n  } # Check thresholds\n  \n  x.p = x\n  x.p[] = 0\n  upper = t(apply(x, 1, FUN = function(x, y){x >= y}, y = thresholds[1, ]))\n  lower = t(apply(x, 1, FUN = function(x, y){x <= y}, y = thresholds[2, ]))\n  x.p[upper] = 1\n  x.p[lower] = -1\n  \n  return(x.p)\n}\n\n\n\n################################\n# Wrapper function definitions #\n\n#' Wrapper function for fixed threshold partitioning\n#' \n#' Wrapper function for \\code{\\link{partition}} for fixed threshold partitioning\n#' \n#' @param x A numeric matrix\n#' @param t Threshold value for use in partitioning.  Values in x >= t will\n#'   become 1 in the return matrix, values in x <= -t will become -1, and values\n#'   in x between -t and t will become 0\n#' @return A matrix comprising values of 1, 0, and -1 to indicate column-wise \n#'   partitioning of the input matrix into positive, neither, and negative sets,\n#'   respectively.\n#' @examples\n#' x = matrix(rnorm(9), 3, 3)\n#' fixed.partition(x)\nfixed.partition <- function(x, t = 3) {\n  # Wrapper function for partition() using the fixed threshold method\n  partition(x, FUN = \".fixed\", t = t)\n}\n\n\n#' Wrapper function for ANN partitioning\n#' \n#' Wrapper function for \\code{\\link{partition}} for partitioning using an\n#' artificial neural network\n#' \n#' @param x A numeric matrix\n#' @param model ANN model to use for partitioning\n#' @return A matrix comprising values of 1, 0, and -1 to indicate column-wise \n#'   partitioning of the input matrix into positive, neither, and negative sets,\n#'   respectively.\n#' @examples\n#' x = matrix(rnorm(9), 3, 3)\n#' ann.partition(x)\nann.partition <- function(x, model = ann.partition.model.1 ) {\n  # Wrapper function for partition() using the fixed threshold method\n  partition(x, FUN = \".ann\", model = model)\n}\n\n\n##########################\n# Non-exported functions #\n\n.fixed <- function(x, t = 3) {\n  if(t < 0) stop(\"t must be a positive number\")\n  t.upper = rep(t, ncol(x))\n  t.lower = rep(t * -1, ncol(x))\n  return(rbind(t.upper, t.lower))\n}\n\n.ann <- function(x, model = ann.partition.model.1) {\n  result = apply(x, 2, FUN = function(y, m) {\n    skew = moments::skewness(y)\n    kurt = moments::kurtosis(y)\n    pred = neuralnet::compute(m, matrix(c(skew, kurt), 1, 2))\n    t.lower = pred$net.result[1]\n    t.upper = pred$net.result[2]\n    return(rbind(t.upper, t.lower))\n  }, m = model)\n  return(result)\n}\n\n.checkMatrix <- function(x) {\n  # This function checks to make sure x is a properly formed numeric matrix or, if not,\n  # coerces it into one if possible.\n  # It is not exported.\n  \n  d = dim(x)\n  if(is.null(d) | (length(d) != 2)) {\n    stop(\"x must be a 2D matrix\")\n  }\n  check.for.factors = sapply(x, is.factor)\n  if(any(check.for.factors)){\n    stop(\"x must not contain factor data\")\n  }\n  \n  # Preserve names\n  rn = rownames(x)\n  cn = colnames(x)\n  \n  # Convert to numeric (in case of character data)\n  x = apply(x, 2, as.numeric)\n  dim(x) = d\n  \n  if(sum(is.na(x)) > 0) {\n    stop(\"x must not contain missing values or values coerced to NA\")\n  }\n  \n  rownames(x) = rn\n  colnames(x) = cn\n  return(x) \n}",
    "created" : 1473972892271.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3592649897",
    "id" : "BF330EEE",
    "lastKnownWriteTime" : 1474225425,
    "path" : "~/MyRPackages/partitionComponents/R/partitionComponents.R",
    "project_path" : "R/partitionComponents.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}